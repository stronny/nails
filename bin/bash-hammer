#!/usr/bin/env bash
#
# This is a wrapper for bash scripts to enable the usage of nails.
# To use it change the script's shebang to "#!/usr/bin/env bash-hammer".
#
# https://github.com/stronny/nails

# ----------------------------------------------------------------------------
# Check the requirements
#
if [[ "$BASH_VERSION" < '4' ]]; then
	echo 'bash-hammer requires bash version 4 or higher'
	exit 1
fi

# ----------------------------------------------------------------------------
# Accomodate for the unset scoping
# http://wiki.bash-hackers.org/commands/builtin/unset
#
function Nails::BashHammer.unset_helper { unset -v "$@"; }

# ----------------------------------------------------------------------------
# Define the magic
#
# usage: require /nail             ([1] source nail/lib/nail.bash)
#        require /nail/path/file   ([2] source nail/lib/nail/path/file.bash)
#        require path/file         (like [2] inside the nail)
#        require                   (like [1] inside the nail)
#
function require {
	local target="$1"
	local nailname nailfile filename
	local caller caller_path caller_line
	local i part dir
	local -a parts dirs
	shift

	read caller_line caller_path caller_path < <(caller 0)
	caller="$caller_path:$caller_line"

	IFS='/' read -a parts <<< "$target"
	# determine nailname
	#
	if [[ "${parts[0]}" || ${#parts[@]} -lt 1 ]]; then
		if [[ -z "${__NAILS_CURRENT[name]}" ]]; then
			echo "$caller: $FUNCNAME: $target: relative target is only valid inside of a nail" >&2
			return 127
		fi
		nailname="${__NAILS_CURRENT[name]}"
	else
		for i in "${!parts[@]}"; do
			part="${parts[$i]}"
			if [[ "$part" ]]; then
				nailname="$part"
				unset parts[$i]
				break
			else
				unset parts[$i]
			fi
		done
	fi
	if [[ -z "$nailname" ]]; then
		echo "$caller: $FUNCNAME: $target: could not determine nail name" >&2
		return 127
	fi

	# determine nailfile (empty is valid)
	#
	nailfile=''
	for part in "${parts[@]}"; do
		[[ "$part" ]] && nailfile+="/$part"
	done

	# look for the script file
	#
	IFS=':' read -a dirs <<< "${__NAILS_PATH}"
	for dir in "${dirs[@]}"; do
		filename="$dir/$nailname/lib/${nailname}${nailfile}.bash"
		[[ "${__NAILS_FILES[$filename]}" ]] && return 0
		[[ -f "$filename" ]] && break
		filename=''
	done

	if [[ "$filename" ]]; then
		__NAILS_FILES["$filename"]="$caller"
		local -A __NAILS_CURRENT
		__NAILS_CURRENT[name]="$nailname"
		__NAILS_CURRENT[path]="$dir/$nailname"
		set -- "$filename" "$@"
		Nails::BashHammer.unset_helper target nailname nailfile filename caller caller_path caller_line i part dir parts dirs
		source "$@"
	else
		echo "$caller: $FUNCNAME: $target: no such file" >&2
		return 127
	fi
}

# ----------------------------------------------------------------------------
# Temporary functions for environment setup
#
function __Nails::Setup.path {
	local -r DEFAULT_PATH=~/.nails:/usr/lib/nails:/usr/local/lib/nails

	case "${__NAILS_PATH}" in
		'') declare -gx __NAILS_PATH="$DEFAULT_PATH";;
		*:) __NAILS_PATH+="$DEFAULT_PATH";;
	esac
}

function __Nails::Setup.current {
	local realname
	local dir
	local -a dirs

	realname="$(readlink -q -e -- "$1")"
	[[ "$realname" ]] || realname="$(readlink -q -e -- "$0")"

	# FIXME won't work if the nail directory is itself a symlink
	declare -gA __NAILS_CURRENT
	IFS=':' read -a dirs <<< "${__NAILS_PATH}"
	for dir in "${dirs[@]}"; do
		if [[ "$realname" =~ ^$dir/([^/]+)/ ]]; then
			__NAILS_CURRENT[name]="${BASH_REMATCH[1]}"
			__NAILS_CURRENT[path]="$dir/${__NAILS_CURRENT[name]}"
			break
		fi
	done
}

# ----------------------------------------------------------------------------
# Setup environment
#
declare -gA __NAILS_FILES
__Nails::Setup.path
__Nails::Setup.current "$1"
unset -f __Nails::Setup.path __Nails::Setup.current

# ----------------------------------------------------------------------------
# Check the arguments
#
case "$1" in
	''|-h|--help)
		echo 'Usage: bash-hammer filename [arguments]'
		echo '       This program is not intended to be run directly.'
		echo '       Please look inside to find out more.'
		exit
	;;
	-v|-V|--version)
		require version
		echo "bash-hammer version ${__NAILS_VERSION}"
		exit
	;;
	--) : ;; # it means "if arg #1 is two dashes, then do nothing"
	-*)
		echo "bash-hammer: $1: invalid option" >&2
		exit 1
	;;
esac

# ----------------------------------------------------------------------------
# Let's get dangerous!
#
shift
source "${BASH_ARGV[$#]}" "$@"
